---
title: 'Blog updates: TypeScript and Hooks'
date: '2019-02-10'
category: 'webdevelopment'
cover: ./stella-ribeiro-631365-unsplash.jpg
tags:
  - javascript
  - typescript
  - gatsby
published: false
---

Instead of writing a new blog post or changing the layout of my site, I've been procrastinating by updating my Gatsby site (this very site) with TypeScript and replacing the few class components that it had with functional components and `useState`.

Unfortunately this means no fresh deep-dives, hot-takes, and what-have-you's. All you're getting is a small update on the educational but slightly purposeless changes I've made.

## TypeScript

TypeScript seems to become the new normal, and I'm fine with that. I'm blissfully ignorant about most programming languages but JavaScript so for me adding TypeScript feels like a great improvement, albeit with a small learning curve.

### Configuration

To update my Gatsby blog with TypeScript, I began by replacing my `eslint` config files, packages and scripts with `tslint` config files, packages and scripts. Nosing around the Gatsby starters using TypeScript I found the packages and config files that I need and cobbled this setup together. After I had everything configured I found out that [TypeScript is going full-in on ESlint](https://eslint.org/blog/2019/01/future-typescript-eslint) and that I just had to change my setup. Ah well, this keeps me off the streets.

After changing all my components to `.tsx` extensions and normal JS files to `.ts` extensions it was time to get rid of those red squiggly lines in VSCode!

### Creating type definitions

One of the first things I noticed were all the `impicit any` errors on the props I was passing. As you might know, Gatsby works with GraphQL and neatly passes your GraphQL queries as props in your components (If this sounds like magic, it's because it is. Seriously, go check out Gatsby).

Since the GraphQL schema language is typed, automating the creation of typescript definitions from a GQL schema seemed like a logical step to me. Luckily, people smarter than me had already taken this step. With the package `grao`

Since GraphQL is typed itself, automating the creation of TypeScript definitions from a GraphQL schema seemed like a logical step that someone smarter than me a

### Creating type modules for packages without types

When using a package that doesn't have any predefined type definitions, you can make or generate your own type definitions. In my case I had a package called `material-colors` which is an object export of all the colors in Google's material design. On converting my components to TypeScript I was introduced with the following error:

```javascript
Could not find a declaration file for module 'material-colors'.
  Try `npm install @types/material-colors` if it exists or add a new declaration (.d.ts) file containing `declare module 'material-colors';`
```

Okay so what now? In my search for an answer, I found the [`dts-gen`](https://github.com/Microsoft/dts-gen) npm package which can generate definitions from `js` files. I installed it globally, ran `dts-gen -m material-colors` from the root of my project and presto, a `material-colors.d.ts` file appeared. I should have type-checking and my error should be gone now, right? Nope! The error is still there and still no type checking.

On inspecting the file generated by `dts-gen` I found the following:

```typescript
export = material_colors;

declare const material_colors: {
    ...
```

Now to be fair, I'm not entirely sure what this means, but I do know we should have declared a module definition somewhere. So changing this file to the following:

```typescript
declare module 'material-colors' {
  export default material_colors;
}

const material_colors: {
  ...
```

Is what did the trick for me. Now last but not least, you should also make sure this file is included in your `tsconfig.json` `types` option.

### Object bracket notation

In case you need to use bracket notation to get the value of an object (like `object[key]`), TypeScript will present you with a `Element has no index signature` error, even if you declared an interface for your object. To fix your code, you need to add this index signature to your Object.

```typescript

interface Animation {
  opacity: number;
  scale: number;
}
interface Transition {
  entering: Animation;
  leaving: Animation;
}

 const transitionStyles: Transition = {
   entering: { opacity: 0; scale: 0.5; };
   entered: { opacity: 1: scale: 1; };
 }

 // Gives "Element has no index signature" error
 transitionStyles['entered];

```

To solve this, we need to add an `index signature` to our `TransitionI` interface:

```typescript
interface Transition {
  entering: Animation;
  leaving: Animation;
  [key: string]: Animation;
}
```

This way the error is resolved and we keep all the type-checking goodness!

## React Hooks

React 16.8.\* gave us hooks, and updating this blog finally gave me a reason to explore them a bit. The gist of hooks is that we can use state and such without making use of class components. Class components will not be deprecated (anytime soon, anyway) so don't go rewriting all your class components, but for all your new components, hooks should be sufficient.

The statefull components I used for this blog only contained some simple UI toggle states which made applying hooks fairly straigt forward:

```tsx
import React, { useState, useEffect } from 'react';
const PostExcerpt: React.SFC<PostExcerptProps> = props => {
  // usesState returns the current state and a function to update this state with
  // useState takes in one argument: The initial stae
  const [isHovering, setHovering] = useState(false);
  // Clean up state
  useEffect(() => {
    // The function which you return from useEffect will be used as 'clean-up'
    // You can use this function to unbind Eventlisteners for example
    return () => {
      setHovering(false);
    };
  }, []);

  return (
    <BlogArticle
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    />
  );
};
```

So that was pretty straight forward! No `this` and binding issues, just a neat way to contain and alter state in a functional component.
